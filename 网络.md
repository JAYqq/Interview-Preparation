[TOC]



## Why

为什么要有网络协议？网络传输的本质是socket之间的字节流传输，但是怎么样能传输更多的信息，比如数据大小、编码等，所以需要网络协议对socket进行封装

## HTTP

### 基本概念

超文本传输协议，是一个明文传输的无状态的协议，无状态也就是无法通过HTTP来维护用户的状态，每次请求都相互独立（所以这里经常会使用cookie或者session来维护状态）。

### GET和POST的区别

GET和POST是Restful API的请求规范，它们本质上没有什么区别，只要服务端和客户端之间请求和解析方式同步，post请求也可以用来代替get

- 从用途上讲，一般GET用户获取资源，POST是传输实体主体
- GET携带参数是放在URL中的，而POST是放在报文主体中传输的，但是这并不代表POST的安全性更高。
- **幂等性**上来讲，GET方法是幂等的，它用于获取资源，所以执行一次和多次结果都是一样的。而POST不是幂等的，因为它会对服务端的数据做出修改而产生变化。
- **缓存**上来讲，GET方法由于是获取资源，所以可以被缓存，而POST请求会和数据库打交道，所以不能缓存

## URL和URI

URI是统一资源标识符，使用URI可以唯一的表示一个资源。

URL是统一资源定位符，是URI的一个子集，它只是URI的一种表示方式。

### 缓存

包括代理服务器缓存和客户端缓存

首先通过头部字段Cache-Control来控制缓存，主要的参数是not-store(对请求或相应都不缓存)、no-cache(强制确认缓存有效性，也就是当前的资源是否是最新的)、private、public

**缓存验证**，一般有两种方式：

- 通过ETAG字段来表示资源的唯一标识，因为URL无法表示唯一资源，可以将ETAG的值放到If-None-Match首部字段，请求到了服务器，就可以判断一下最新资源的ETAG值是否相同，如果一致就返回304，这样就可以直接用缓存的资源。
- 用Last-Modified，判断资源是否被修改过，但是由于这个值只精确到1秒，所以一般用作ETAG的备选方案

### 几个重要的状态码

3XX 重定向

- 301   永久性重定向
- 304   此状态码适用于客户端发送了一个有条件的请求（ If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since ）。比如客户端想获取某个资源，并且是在XXX时间修改过的新的资源，如果这个资源没有修改，服务端就返回304给客户端。

4XX 客户端错误

- 400 Bad Request ：请求报文中存在语法错误。
- 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
- 403 Forbidden ：请求被拒绝。
- 404 Not Found

5XX 服务器错误

- 500 Internal Server Error ：服务器正在执行请求时发生错误。
- 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

### HTTP请求格式

- 请求行

  请求方法、URI路径、HTTP协议版本

- 请求头

  缓存相关信息（Cache-Control，If-Modified-Since）、客户端身份信息（User-Agent）等键值对信息。

- 空行

- 请求主体

  客户端发给服务端的请求数据，这部分数据并不是每个请求必须的。

### 响应格式

- 状态行
- 响应头部
- 空行
- 响应数据

### Keep-Alive

持久连接，为了防止对每个资源都需要一次握手去获取资源。

### 管线化

持久连接使得很多的请求可以并行发生，这样使得请求资源的速度得到了提升。

### HTTP1.0和1.1的区别

- HTTP1.0默认是短连接，所以每次请求一个资源都需要建立一次握手；而1.1默认是长链接，多个请求可以复用一个连接，但是出现阻塞还是会建立新的连接。**keep-alive解决的主要问题是反复创建TCP连接的消耗**
- HTTP1.1添加了HOST首部，这是因为多个虚拟主机可以运行在一个服务器上，因此一个IP可能会解析到多个域名，所以需要HOST表示具体的主机
- 实现断点发送数据，通过实体首部的Content-Range字段设置具体的范围

### HTTP1.1和HTTP2.0的区别

https://zhuanlan.zhihu.com/p/89471776

https://www.zhihu.com/question/34074946/answer/108588042

- 管线化。在1.1中，keeplive的方式还是只能请求->响应，然后下次请求这样顺序发送，而在2.0可以在客户端一次性发送多个请求

- 二进制贞。**取代了 HTTP1.x 的文本格式，二进制格式解析更高效**，二进制帧的方式。2.0中**数据传输的最小单位**，在 HTTP 2.0 中，它把数据报的两大部分分成了 header frame 和 data frame。也就是头部帧和数据体帧。多个帧可以乱序发送，因为每个帧带有编号可以重新组织称有序的，服务器还是要根据FIFO的方式处理请求。

   每一帧都包含几个字段，有**length、type、flags、stream identifier、frame playload**等，其中type 代表帧的类型，如果是HEAD表示是头部贞。

- 多路复用。**管线化的实现是基于多路复用的**，这里指的是对于一个域名的所有请求都走一个连接，并且对于每个链接，2.0给出了一个 **流**的概念，每个流是一个全双工通信的虚拟管道，可以将报文组织称帧的形式通过不同的流发送。

- 首部压缩。采用了HPACK算法，用header字段表里的索引代替实际的header。

  http/2的HPACK算法使用一份索引表来定义常用的http Header，把常用的 http Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。

  例如 :method=GET 使用索引值 2 表示，:path=/index.html 使用索引值 5 表示，如下图：

  ![img](https://pic3.zhimg.com/v2-164b9920157f4f0ae90dd7b0714899b5_b.jpg)

  完整的列表参考：HPACK Static Table③。

  只要给服务端发送一个 Frame，该 Frame 的 Payload 部分存储 0x8285，Frame 的 Type 设置为 Header 类型，便可表示这个 Frame 属于 http Header，请求的内容是：

  ```text
  1 GET /index.html
  ```

### 基于HTTP协议延伸的其他协议

#### SPDY

由于1.0和1.1还是存在一些问题，比如请求只能从客户端开始，还有首部重复发送等问题，所以出现了像Ajax局部刷新页面而不是整页刷新，还有像Comet，暂时保留请求信息，等有数据更新了再返回响应，而不是马上响应，通过这样的方式来实现服务器的推送。但是依旧会为了保留连接造成资源耗费。

所以SPDY介于HTTP（应用层）和TCP（传输层）之间的会话层，并在表示层用SSL加密，支持了主动推送、首部压缩的功能

#### Websocket

只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相 比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。 

WebSocket优势在于提供了message的概念，比基于字节流的tcp socket使用更简单，同时又提供了传统的http所缺少的长连接功能

需要用到HTTP首部的upgrade字段，设置成websocket才可以

## HTTPS

### TLS握手过程

HTTPS是通过对称和非对称加密技术共同实现的加密传输协议

过程是：

- 服务端向第三方机构申请证书，数字证书=网站信息（未加密）+数字签名

  第三方将网站信息（信息中包含服务端的公钥）加密后(数字摘要算法)，然后第三方用自己的私钥加密证书中已经加密过的网站信息。最后给到服务端

- 客户端向服务端申请证书。

- 客户端拿到证书以后用向第三方申请的公钥（很多浏览器已经在本地储存了常见第三方的公钥）解密数字签名，验证合法性：合法性就是客户端拿到证书以后第三方公钥解密出加密过的网站信息，然后用同样的数字加密算法重新加密网站信息，查看两者是否相等。

- 如果合格，客户端生成秘钥，然后用服务端的公钥加密后发送给服务端

- 服务端收到后用自己的秘钥非对称解密，得到客户端秘钥，然后客户端用秘钥进行数据加密传输。

### http和https的区别

- http是一种明文传输协议，而https是在http的基础上进行了加密

### https的缺陷

- 因为需要进行加密解密等过程，因此速度会更慢；
- 需要支付证书授权的高额费用。

### 为什么很多网站还是不用HTTPS

HTTPS主要目的是为了保护用户的敏感信息，然后对于很多公共资源没有必要加密，得不偿失。

## TCP

### TCP首部解析

![](https://camo.githubusercontent.com/2e30711bdf748be3b6355a1903df0b59bd7a093f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35356463346538342d353733642d346331332d613736352d3532656431646432353166392e706e67)

#### 源端口和目的端口

分别是16位，总共占了4个字节。

#### 序号（seq）

占了32位，表示初始化序号的值。

因为TCP是面向字节流的传输协议，所以每个字节都需要进行编号，这样才能为可靠传输的各种机制提供保证，三次握手的主要目的也就是交换彼此的seq

#### 确认号（ack）

占了32位

表示期望收到的下一个字节序号。。

确认序号为上次接收的最后一个字节序号加1.只有确认标志位(**ACK**)为1的时候，确认序号才有效。

#### 数据偏移

也叫首部长度，占了4个位

表示数据开始的地方距离TCP段起始地址有多远，也就是TCP首部的大小。

数据偏移以32位位单位长度，因为占了4个位，所以（1111）二进制表示的十进制就是15，32位就是4个字节，所以15*4=60字节，

#### 保留位

6位

#### 标志位

6位

- URG：该位设为 1，表示包中有需要紧急处理的数据， 当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据），而不要按原来的排队顺序来传送。当URG置1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。这时要与手不中紧急指针（Urgent Pointer）字段配合使用。
- ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。
- PSH：提示接收端立即从缓冲读走数据。
- RST：表示要求对方重新建立连接（复位报文段）。
- SYN：表示请求建立一个连接（连接报文段）。
- FIN：表示关闭连接（断开报文段）。

#### 窗口

16位

#### 校验和

16位

#### 紧急指针

16位

#### SACK

这属于TCP首部选项中的一项。

TCP通信时，如果发送序列中间某个数据包丢失，TCP会通过重传最后确认的包开始
的后续包，这样原先已经正确传输的包也可能重复发送，急剧降低了TCP性能。为
改善这种情况，发展出SACK(Selective Acknowledgment, 选择性确认)技术，使
TCP只重新发送丢失的包，不用发送后续所有的包，而且提供相应机制使接收方能
告诉发送方哪些数据丢失，哪些数据重发了，哪些数 据已经提前收到等。

### TCP/IP四层协议

自下而上依次是

#### 数据链路层

- 处理数据在以太网数据链路上的传输
- 为上层应用提供了物理网络设备的一些接口

对应的网络协议有ARP（IP地址转换成MAC地址）和RARP

#### 网络层

网络分为局域网和广域网，广域网需要很多的网络设备（路由器、交换机）来连接彼此，即通讯的两台主机一般不是直接连接，而是通过多个中间节点(路由器)连接的，从而形成网络拓扑连接。

协议应用
  (1) **IP协议**: IP协议(Internet Protocol)是网络层最核心的协议，它根据数据包的目的IP地址来决定如何投递该数据包。若数据包不可直接发送给目标主机，那么**IP协议就为它寻找一个合适的下一跳路由器**，并将数据包交付给该路由器去转发，如此循环直至到达目标主机或者发送失败而丢弃该数据包。
  (2) **ICMP协议**: ICMP协议(Internet Control Message Protocol，因特网控制报文协议)是IP协议的补充，用于检测网络的连接状态，如ping应用程序就是ICMP协议的使用。ICMP包发送是不可靠的，所以不能依靠接收ICMP包解决网络问题；ICMP与TCP/UDP不同，它们是传输层协议，虽然都具有类型域和代码域，但是前者和后者不同，ping用到的ICMP协议，不是端口。ICMP协议使用的是IP协议而非使用下层协议提供的的服务，所以严格来讲它并非网络层协议，而是网络层程序。

#### 传输层

为应用程序隐藏了数据包跳转的细节，负责数据包的收发、链路超时重连等。

协议应用
  (1) TCP协议: TCP协议(Transmission Control Protocol, 传输控制协议)为应用程序提供可靠的、面向连接的、基于流的服务，具有超时重传、数据确认等方式来确保数据包被正确发送到目的端。因此TCP服务是可靠的，使用TCP协议通讯的双方必须先建立起TCP连接，并在系统内核中为该连接维持一些必要的数据结构，比如连接的状态，读写缓冲区，多个定时器等。当通讯结束时双方必须关闭连接以释放这些内核数据。基于流发送意思是数据是没有长度限制，它可源源不断地从通讯的一段流入另一端。
  (2) UDP协议: UDP协议(User Datagram Protocol, 用户数据报协议)与TCP协议相反，它为应用程序提供的是不可靠的、无连接的基于数据报的服务。
  无连接: 通讯双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收方的地址；
  基于数据报的服务: 这是相对于数据流而言的，每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其内容一次性读出，否则数据将被截断。
  UDP不具有发送时是被重发功能，所以UDP协议在内核实现中无需为应用程序的数据保存副本，当UDP数据报被成功发送之后，UDP内核缓冲区中该数据报就被丢弃了。
  (3) SCTP协议: SCTP(Stream Control Transmission Protocol, 流控制传输协议)是为了在因特网上传输电话信号而设计的。

#### 应用层

前三层都是在操作系统的内核空间中，而应用层是在用户空间实现的，负责处理众多业务逻辑，如文件传输、网络管理。

协议应用
  应用层的协议很多，如：
  (1) telne协议: 远程登录协议，它使我们能在本地完成远程任务
  (2) OSPF协议: OSPF协议(Open Shorttest Path First, 开放最短路径优先)是一种动态路由更新协议，用于路由器之间的通讯，以告知对方自身的路由信息
  (3) DNS协议: DNS协议(Domain Name Service, 域名服务)提供机器域名到IP地址的转换。

### OSI七层协议

https://blog.csdn.net/yaopeng_2005/article/details/7064869

一图胜千言

![](http://hi.csdn.net/attachment/201201/5/0_1325744597WM32.gif)

### TCP 协议如何保证可靠传输

- **校验和**： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

- **应答机制**

- **流量控制**：  只关心发送方和接收方的窗口大小，而不关心链路中的具体情况。

  TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据（这个叫做窗口大小，放在TCP头部窗口字段）。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。（这里还有一个ACK和窗口大小的合并，这样不用分成两个包来传输了，提高了效率）。并不是每次发送一个发送窗口大小的数据，而是发送MSS，所以这个MSS可能会比发送窗口小

- **拥塞控制**： 考虑到链路中的阻塞情况，主要就是维护拥塞窗口

  **整理一下下面，宏观上看，拥塞控制主要依靠慢启动、拥塞避免、快重传和快恢复，但是依旧面临丢包问题，那么在拥塞避免算法加一递增到丢包了，如何检测出丢包，并且丢包就涉及到重传机制，主要依靠超时重传和快重传**

  涉及到整个网络的拥塞情况，并作为一个**拥塞窗口**(cwnd)的状态变量，放入TCP头部中实现拥塞控制。发送窗口大小=min(接收方窗口大小，拥塞窗口大小)，主要算法有：

  - 慢开始

    较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。

    ![img](https://img-blog.csdn.net/20180506145526553?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ1OTA3NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

  - 拥塞避免

    拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.

  - 快重传（FRR）与超时重传

    **都是用来确认丢包的**

    有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段（**主要结合快恢复**）
    
    超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。（**主要用在慢开始中进入拥塞避免后判断超时**）
    
    **快重传解决了超时重传的限定time问题，它不需要等待超时时间。另外快重传在**
    
    ![img](https://upload-images.jianshu.io/upload_images/3256507-d97c8b1425c23a6e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1174/format/webp)
    
  - 快重传和快恢复

    快恢复相对于拥塞避免的好处就是抛弃了慢启动，在通过快重传确认丢包以后直接将拥塞窗口变为一半，而不是从1开始

    ![img](https://img-blog.csdn.net/20180506145535862?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ1OTA3NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- **停止等待协议**: 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就- 停止发送，等待对方确认。在收到确认后再发下一个分组。停止等待协议可以理解成滑动窗口协议的低等版，也就是当接受和发送窗口都为1的时候的模式。因为滑动窗口一直全力发送，到后面一定会出现发送窗口为1接受也是为1,。

### 滑动窗口

滑动窗口的最大值为2^16-1字节，因为首部中代表滑动窗口字段就是16位。

#### 如何扩大滑动窗口

修改TCP首部选项中的窗口扩大因子，也可以修改系统本身的窗口大小：

/proc/sys/net/ipv4/tcp_window_scaling — 支持更大的TCP窗口.
/proc/sys/net/core/rmem_default — 默认的接收窗口大小
/proc/sys/net/core/rmem_max — 接收窗口的最大大小
/proc/sys/net/core/wmem_default — 默认的发送窗口大小
/proc/sys/net/core/wmem_max — 发送窗口的最大大小

#### 为什么需要滑动窗口？

如果没有滑动窗口，那么如果出现接收方的速度小于发送方，照这样下去，接受方的接受缓冲区很快就满了，接收方考虑到内存问题一定会选择抛弃一些包导致了不可靠，所以需要一个窗口来

滑动窗口是在吞吐量和发送数据的有序性上面做了一个兼并，也就是**不需要每发送一个包就等待它的ACK**，而是可以连续发送多个包，只需要收到最后一个序号的确认报就表示前面的包都收到了。**但是如果前面有包没有收到，那么滑动窗口发送完一个窗口大小后就会停止等待，直到超时重传**，收到了这个包的确认报之后才会往后滑动，这样保证了窗口之前的数据包都是已经被成功发送的数据包。

另外发送窗口的大小也需要根据具体情况做出改变，发送窗口大小=min(接收方窗口大小，拥塞窗口大小)

1. **网络上的传输是没有连接的，包括TCP也是一样的**。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。

### TCP三次握手

#### 为什么需要三次握手？

第一次客户端请求链接重传对服务端影响：

客户端发送的连接请求如果在网络中**滞留**，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

对于第二次服务端返回的请求失效：

如果服务器返回的SYN+ACK的包在网络中丢失了，那么就会导致服务端已经处于Establish的状态，准备传输数据，但是其实客户端还没有连接成功，必须重传连接包，然后服务端又会重新简历新的连接，这样就导致了前一个连接端口一直开着直到**保活计时器**结束。

#### 关于连接时SYN超时。

试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。

#### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个**保活计时器**，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

#### 如果第三次握手服务端失败怎么办

服务端会有连接定时器，如果到了就会重传，1 2 4 8 16 32，如果还是没有收到ACK，那就会发送一个RST，让客户端进入close状态。
如果A发出的RST B没有收到：
A还是释放连接，closed。
B不知道A关闭了连接，继续发送数据
A收到一个发送给已经closed的端口的报文，认为是异常现象，直接丢弃并发送一个RST报文给对方。
如果B一直收不到RST，也不会收到对方的ACK，那么会一直重传上次的数据，直到重传超时，关闭连接

#### SYN队列和Accept队列

也叫做半连接队列和全连接队列，当服务端调用listen后，系统就会给这个listen的socket创建两个队列，当第一次握手的时候，只要服务端收到了SYN，那么就会把这个连接放到半连接队列，也就是这个队列中的连接状态都为SYN_RCVD状态。

三次握手完成后才会将这个请求放到已完成队列中，都是ESTABLISH状态。

处于“LISTENING”状态的TCP socket，有以上两个独立的队列。**SYN队列**储存收到的SYN连接，这个队列的任务就是进行SYN和ACK确认然后判断重传（这里的重传也就是上面的63秒）发送完SYN+ACK之后，SYN队列等待从客户端发出的ACK包（也即三次握手的最后一个包）。当收到ACK包时，首先找到对应的SYN队列，再在对应的SYN队列中检查相关的数据看是否匹配，如果匹配，内核将该连接相关的数据从SYN队列中移除，创建一个完整的连接（对应内核代码的结构体：[struct inet_sock](https://elixir.free-electrons.com/linux/v4.14.12/source/include/net/inet_sock.h#L183)），并将这个连接加入Accept队列。

**Accept队列**中存放的是已建立好的连接，也即等待被上层应用程序取走的连接。当进程调用accept()，这个socket从队列中取出，传递给上层应用程序。

#### SYN Flood攻击

就是利用了这个63秒，攻击者在客户端发送了TCP的SYN包之后就马上下线，这样就会导致服务器不得不重传等待63秒，如果这个过程被重复，那么SYN队列就会满掉，导致其他的链接无法进行。

**解决** **SYN cookies 算法**

我们知道，`TCP`连接建立时，双方的起始报文序号是可以**任意**的。`SYN cookies`利用这一点，按照以下规则构造初始序列号：

- 设`t`为一个缓慢增长的时间戳(典型实现是每64s递增一次)
- 设`m`为客户端发送的`SYN`报文中的`MSS`选项值
- 设`s`是连接的元组信息(源IP,目的IP,源端口，目的端口)和`t`经过密码学运算后的`Hash`值，即`s = hash(sip,dip,sport,dport,t)`，`s`的结果取低 **24** 位

总结来说，三次握手的主要目的就是交换彼此的初始序号，系统需要对SYN队列中的所有连接进行资源分配，也就是分配空间去储存此次请求的信息（四元组，MSS，时间戳），但是由于现在SYN队列满了，所以我们就只能在不分配资源的情况下获取这些信息，因为已经没有队列去记忆初始序号了。SYN cookie方法 **通过构造一个初始序号，这个序号采用了哈希算法，然后制造一个SYN+ACK的包发送给客户端，根据TCP规范，客户端必须返回一个ACK确认包，并且之中有确认序号ack（n+1），服务端接收到这个确认包之后，就可以根据ack-1得出一开始的序号值**，这样就完成了一次连接，可以进入到Accept队列中。

#### RTT

**round-trip time**

RTT=传播时延（往返哒）+排队时延（路由器和交换机的）+数据处理时延（应用程序的）

### TCP四次挥手

#### 为什么需要四次挥手

其实四次挥手和三次握手最主要的不同在于第二次连接，握手的时候服务端发送的SYN+ACK既包含了请求连接的意向，也包含了对之前客户端发起连接请求的确认，而挥手的时候，FIN和ACK是分两个包发出去的，这是因为服务端这边数据可能还没有完全发送完，所以需要先返回ACK让客户端进入FIN_WAIT2状态。

#### MSL

maximum segment lifetime (最大分节生命期），这是一个 IP 数据包能在互联网上生存的最长时间，超过这个时间 IP 数据包将在网络中消失 。MSL 在 RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒。

#### TIME_WAIT

状态维持时间，是两个 MSL 时间长度，也就是在 1-4 分钟。Windows 操作系统就是 4 分钟。

主要的两个作用：

1. 为了防止最后的ACK没有到达被断开的一方，在timewait时间内可以重传最后的ack
2. 一个数据包在网络中的生命周期是MSL，而timewait的长度是两个MSL这样就可以让所有本次连接的包都被耗死在网络中，而不会去影响下一次相同的连接。

1. 慢启动和拥塞避免算法。

   **拥塞窗口是发送方控制流量，滑动窗口是接收方控制流量**

   而发送窗口是取两者最小值

2. timewait出现过多拥塞怎么解决？

   https://zhuanlan.zhihu.com/p/40013724（必看）

   1. 打开SYN-cookie，来应由于过多的timewait占用资源而让新的连接连握手的完成不了。

   2. **net.ipv4.tcp_tw_reuse = 1**  定义了TCP的新选项，一个四个字节的时间戳，时间戳中一个是发送方发送时的时间戳，另一个是接收方接受的时间戳。可以让socket可以重复被新的连接使用，这个只适用于发送方，并且timewait的时间戳和新连接的时间戳至少隔了一秒。对于接受方来说，如果如果由于没有收到ACK重发FIN后接收到正确的ACK，那么就正常挥手，但是如果客户端这个连接已经被重用，那么接受方就会接收到一个RST包，这会让服务端脱离LAST_ACK状态。由于使用了时间戳，所以在timewait时间内的重复的数据包会因为过期导致失效。这个主要的目的是主动方如果出现大量timewait，就可以进行连接复用。所以配置在被动方没有什么用

   3. 如果是内网环境，可以开启**net.ipv4.tcp_tw_recycle**，这个主要在被动方打开，依赖于timestamp，是直接毁掉这个连接，默认时间时一个RTO（数据包重传时间）而不是跟reuse一样去复用。如果这个配置在NET环境下，也就是以多台电脑和负载均衡服务器这个环境下的负载均衡器上，由于每一台外设电脑都是和负载均衡器一个端口进行五元祖（源IP+源端口，目标IP+目标端口，+协议）连接时，由于每台电脑的内核时间戳不一致，所以导致一个RTO时间内只能有一个连接成功，其他连接的数据包发过来可能会因为时间戳过期直接抛弃。

      内核会记住**客户端上次发来数据包的时间戳**, 如果发来的数据包时间戳小于内核记录的最后发来的数据包时间戳, 那么将会丢弃此数据包

   4. 修改timewait的值，下下策。

   5. 增加可用端口的数量。


#### TCP和UDP的区别

首先，从宏观上来讲，TCP协议是面向连接的可靠的字节流传输协议，面向连接是指一次通信需要提前三次握手，事后四次挥手，可靠指的是TCP通过一整套机制包括应答机制、流控、重传机制、拥塞控制、校验和；而UDP是不可靠的基于报文的传输协议，因为他没有

#### TCP分段和IP分段

ip协议本身是会进行分段的，分段的标准就是MTU，这个的大小就是数据包的大小加上ip头部和tcp头部的大小，因为数据链路层的传输帧大小是有限的，网络层不能一下子把所有的数据都塞饭数据链路，所以规定了最大传输单元mtu，ip协议以这个单位对报文分段，IP首部中有个字段片偏移，在IP数据报长度大于MTU的时候对数据报进行分片，片偏移用来表示数据报在原来分组的相对位置，以8个字节为偏移单位。
tcp的分段是基于mss的，这个大小相当于mtu大小减去ip和tcp头部大小。

udp没有mss的概念，所以没有分段，直接交给ip进行分段

在三次握手的时候接收方和发送方都会声明自己MSS，因为接收方和发送方的MTU可能是不同的，最终会以较小的MSS为准。

### Cookie和Session区别

1. cookie可以用来做会话跟踪，也可以用来储存其他的信息。session就是用来会话跟踪的。

2. cookie储存在客户端，每次请求时需要客户端携带cookie来维持会话状态。session保存在服务端，以session_id为索引的数据结构，所以当用户量比较大的时候会占用大量内存影响服务器的性能。session一般依赖于cookie实现，但是也可以通过URL重写来实现。

3. cookie分为会话型cookie和持久性cookie。cookie的安全问题主要体现在如果一个网站使用cookie作为用户唯一标识，那么攻击者可以盗用cookie来伪装用户。可以设置HTTPONLY禁止掉JS操作cookie，或者设置cookie的secure属性，这样只能用HTTPS传输cookie。也可以在cookie中设置一些像UserAgent来提高安全性。

   session的安全问题主要在于攻击者可以用session_id来伪装用户。

4. cookie还有一个很重要的问题就是大多移动设备不支持

5. cookie存在跨域问题，因为cookie是和域名绑定的，所以无法使用这个网站的cookie去访问另一个网站，如果是二级域名的话，可以设置cookie的domain参数。Session存在共享session问题，因为sessionID保存在服务器上，如果应用做了负载均衡，那么当这个客户端的请求被转发到另一台没有储存session的服务器上，就会无法识别，主要策略有：

   - 固定每个用户到指定的服务器。但是这样导致了单点问题，如果这个服务器宕机了，那么用户就无法访问。
   - session复制。但是也无法解决session耗费资源的问题，并且数百台服务器之间的session同步问题也很头疼。
   - session集中处理，放在第三方服务器中。这样虽然避免了负载均衡后的服务器的session消耗，但是如果这台第三方服务器宕机了，那就凉了
   - Token

#### 小问题

1. epoll读到一半又有新事件来了怎么办？

   避免在主进程epoll再次监听到同一个可读事件，可以把对应的描述符设置为**EPOLL_ONESHOT**，效果是监听到一次事件后就将对应的描述符从监听集合中移除，也就不会再被追踪到。读完之后可以再把对应的描述符重新手动加上。

2. 为什么边缘触发一定要配合非阻塞IO？

   因为在ET模式下，在检测到socket上有IO事件发生后就可以通过epoll_wait得到有事件通知的文件描述符，对于每一个文件描述符，如果是有数据那么就一直读知道但会EAGAIN为止，但是如果是阻塞模式，那么最后一次读到没有数据的时候线程就会停止阻塞在这里。

   3. 

      Linux epoll机制是通过红黑树和双向链表实现的。 首先通过epoll_create()系统调用在内核中创建一个eventpoll类型的句柄，其中包括红黑树根节点和双向链表头节点。然后通过epoll_ctl()系统调用，向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败，并向内核注册回调函数。最后通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中，此时epoll_wait函数被唤醒，返回就绪好的事件。

   4. EPOLLONESHOT

      因为在使用ET模式的时候，如果是读缓冲区比较小然后一次读取数据进行数据解析，这时候如果这个socket又到来一个事件，系统就会调用另一个线程处理这个事件，导致了两个线程的竞争。所以加上EPOLLONESHOT后可以保证一个socket再同一时刻只能被一个线程处理，并且处理完后需要重置这个EPOLLONESHOT

### Socket

https://zhuanlan.zhihu.com/p/109826876

socket是应用层和传输层之间的一个抽象层，对TCP等传输层协议进行封装

linux中socket是文件的形式，而windows中是网络连接，而不是文件的形式

socket属于传输层，解决的事如何可靠传输的问题，http是应用层，解决的是如何封装数据包的问题。

## IP



## DNS

dns就是域名解析服务器，解析的流程一般如下：

1. 首先查看本地缓存，hosts文件中有些会定义域名和IP的对应

2. 本地没有缓存就去本地域名服务器，这个服务器设置是在/etc/resolv.conf中指定的，里面的nameserver按照顺序下来解析

3. 如果前两者都没有，那么就需要去进行递归查询或者迭代查询：以www.baidu.com 为例

   **递归查询**

   - 本地域名服务器先去询问根域名服务器（.root）
   - 如果没有找到，根域名服务器就去询问顶级域名服务器（.com）
   - 如果没有找到，顶级服务器就绪询问二级域名服务器（.baidu）
   - 如果还没有找到，就再往下递归寻找（.www）
   - 找到以后就将解析到的信息回溯给上一级服务器，直到根域名服务器反馈给本地然后返回给客户端

   **迭代查询**

   - 客户端先去问本地服务器
   - 没有的话客户端再去问根域名服务器
   - 再没有就再去问顶级服务器
   - 就这样，问到了以后直接返回给客户端，而不是往上回溯


## NAT

NAT是网络地址转换。因为如果每一台机器都分配公网ip，那么就很浪费ip地址。在局域网中，比如公司，一般就是可以在内部分配私有IP，这些ip是无法直接连接广域网的，无法上网，所以至少需要有一台具有公网IP的机器，去代替这些机器访问互联网，这就涉及到网络地址转换。主要分为：

- Basic NAT

  一对一的地址转换，也就是一个局域网中的每个机器固定会通过某个IP去访问互联网，并且一个公网IP不能不同被使用

  在实际中不常用，因为其实没有很好的解决IP地址紧缺的问题

- NAPT

  多对一，也就是多个机器能同时借助一个公网IP去访问互联网。这里其实用到了端口，也就是IP+PORT实现对同一个IP的并行使用

上面是主要的两种方式，其他还有延伸开来基于此：

- 静态NAT/NAPT

  静态NAT就是单单一对一的IP固定

  静态NAPT就是IP+端口的固定

- DNS mapping

  私网用户希望通过域名访问位于同一私网的内部服务器，而 DNS 服务器却位于公网，这样就可以使用dns mapping，nat服务器直接可以通过域名+公网IP+内部主机私有IP来解析

## RPC

RPC是一种远程通信协议，通常用在分布式系统之间解决系统之间的通信问题。

其实http也可以解决通信问题，但是需要开发者显示地去发起http请求，所以RPC就可以在开发者层面屏蔽显示的请求，而是像调用一个函数一样，这个屏蔽工作就是利用代理模式，这个代理模式内部就是通过http客户端实现（比如阿里的Dubbo）。

### **RPC要解决的两个问题：**

**1. 解决分布式系统中，服务之间的调用问题。**

**2. 远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。**

### 优势

1. 在接口非常多的情况下，使用http就会导致每次需要三次握手，而RPC是长连接，减少网络的开销。
2. 解耦服务，使用了动态代理模式

