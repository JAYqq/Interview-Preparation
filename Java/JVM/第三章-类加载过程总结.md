# Java虚拟机是如何加载Java类的?

从字节码文件到java类一般需要jvm三个过程：加载、链接、初始化

## 加载

- 指查找字节流，并且据此创建类的过程
- 将字节流中的静态数据结构转换成方法区中的运行时数据结构
- 在内存中生成该类的`java.lang.Class` 实例，作为 **方法区** 中该类各种数据的访问入口

非内部类的加载需要由jvm借助 **类加载器**帮助加载。

所有类加载器有一个共同祖先：**启动类加载器**

除了启动类加载器，另外的加载器都是java.lang.ClassLoader 的子类，因此它们 **都有对应的java对象**，这些类加载器需要先被 **某个公共加载器** 加载器加载至jvm才能加载其他类。

#### 双亲委派模型

每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。

**目的是为了避免重复加载类**

### 重要的三个核心类加载器（Java9之前）

#### 启动类加载器

负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包中的类。

#### 扩展类加载器

父加载器是启动类加载器。

负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类

#### 应用类加载器（最常见的）

负责加载应用程序路径下的类，也就是classpath指定下的类

#### Java9之后的变化

Java 9 引入了模块系统，扩展类加载器被改名为平台类加载器（platform class loader），并分担了启动类加载器的大部分工作。

### 加载器的命名空间

同一个类经过不同加载器加载到jvm是不同的两个类，由于在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的，相当于：name=classloadername + classname

作用：运行同一个类的不同版本。

至此，不同环境的字节码被加载进了JVM

## 链接

**将创建成的类合并至 Java 虚拟机中成为可执行类**，分为验证、准备、解析

### 验证

- 确保被加载类能够满足 Java 虚拟机的约束条件

因为jvm接受的字节流来源是多种多样的，除了jdk自身的类，还有来自网络、动态生成的，因此需要进行合法性验证

### 准备

- 为被加载类的静态字段分配内存，并设定初始值

  比如：

  ```java
  private static int num = 123;
  ```

  在准备阶段就会被设定初始值0，但是如果是 static final修饰，初始值就是123

- 建立具体类、方法与地址的映射关系，符号引用（类名+方法名+参数类型+返回类型=符号引用）指代具体方法，如果有虚函数这样，做法和C++差不多，也是映射到一个虚表中

### 解析

将符号引用解析为实际引用（包含具体地址）。

如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载，不包括链接和初始化。

至此，加载进来的类已经被建立各种实际引用，知道了各个函数、各个类的具体地址。

## 初始化

**为标记的静态变量赋值**

### 常量

被final和static修饰的基本类型或字符串，会被JVM标记成常量

### 初始化触发时机

1. 当虚拟机启动时，初始化用户指定的主类；（如Main函数所在类）
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

至此，所有程序中需要的类，已经从字节码到Java类，到可执行，到常量初始化。



## 参考阅读

1. http://songkun.me/2019/11/24/2019-11-24-java-jvm-class-load-what-each-step-does/
2. https://zhuanlan.zhihu.com/p/54800987



