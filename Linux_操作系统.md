[TOC]



## glibc

glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。glibc除了封装[linux](https://baike.baidu.com/item/linux)操作系统所提供的[系统服务](https://baike.baidu.com/item/系统服务/11027121)外，它本身也提供了许多其它一些必要功能服务的实现

## CPU模块

cpu包含控制单元，运算单元，数据单元。

- 数据单元包括cpu高速缓存和寄存器组，为了不让cpu浪费时间去通过数据总线到内存拿数据。计算完的数据暂时放在数据寄存器，最终会有指令讲数据放到内存中
- 运算单元只管算
- 控制单元是一个统一的指挥中心，叫做指令指针寄存器。它不断的从内存中获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。而每个进程都会有一个程序在硬盘上，是一个二进制文件，包含了各种命令。
- 总线
  总线包括地址总线和数据总线，上面放数据取数据都是靠这两条线。地址总线负责传递内存地址，说明去哪里拿东西;数据总线负责传递数据。

## 系统初始化

从内核的启动从入口函数start_kernel开始进行内核初始化，主要做了：

1. 创建0号初始进程，不是由fork或者kernel_thread方法产生的。
2. 初始化内存管理模块
3. 创建1号进程，这是第一个用户态进程，有了用户态就需要做权限管理，x86架构提供分层权限机制，分成四个等级，从内核态资源向用户态资源等级依次递减。
4. 这时候进入了保护模式，并且处于用户态，内核态到用户态这边因kernel_thread通过do_execve系统调用去运行了ramdisk这个基于内存的文件系统中的一个文件，“/sbin/init”“/etc/init”“/bin/init”“/bin/sh”中的一个。因为磁盘的读取是需要驱动的，而不可能把磁盘的驱动放到内核中仅仅提供初期化功能。
5. 上面do_execve这个系统调用会保存这个init二进制文件的代码段，数据段，初始化栈指针寄存器、指令指针寄存器为第一条指令。
6. 执行完后就恢复寄存器，这样CS 和指令指针寄存器 IP 恢复了，指向用户态下一个要执行的语句。DS 和函数栈指针 SP 也被恢复了，指向用户态函数栈的栈顶。所以，下一条指令，就从用户态开始运行了。
7. 1号进程时所有用户态进程的祖先，管理所有用户态子进程，所以这里还需要创建2号进程管理所有内核态进程。

## 系统调用

用户态到内核态的方式就是通过系统调用，系统调用涉及到很重要的就是如何保存进程状态。保存状态信息主要是保存到regs这个数据结构中，因为Linux二进制的格式是ELF（Executable and Linkable Format，可执行与可链接格式），包含了二进制代码段，数据段，栈指针寄存器，指令指针寄存器

## 进程

### 编译阶段

在Linux下，程序进行编译的时候，经过预处理、编译、汇编、链接四个阶段，汇编完以后就成为.o的二进制文件，这个二进制文件在Linux下有严格的格式规定，**这个格式叫做第一种格式的ELF（可执行可链接格式）**，根据这个.o文件可以在链接阶段变为静态链接和动态链接。ELF包含了：

![](https://static001.geekbang.org/resource/image/e9/d6/e9c2b4c67f8784a8eec7392628ce6cd6.jpg)

- .text：放编译好的二进制可执行代码.
- .data：已经初始化好的全局变量.
- .rodata：只读数据，例如字符串常量、const 的变量
- .bss：未初始化全局变量，运行时会置 0
- .symtab：符号表，记录的则是函数和变量
- .strtab：字符串表、字符串常量和变量名

**这个文件中还没有栈数据，因为这个进程还没有起来，所以栈数据还没有存在**。并且这个文件是不可执行的，因为比如我们的cpp文件里面调用了另一个文件的一个函数，但是在这个静态文件中没有体现。

### 链接过程

将多个可重定向ELF文件相互链接后产生链接文件（.a文件，静态链接库），这个是ELF的第二种格式：

![](https://static001.geekbang.org/resource/image/1d/60/1d8de36a58a98a53352b40efa81e9660.jpg)

这里的每个模块都是多个文件混合起来的模块，所以静态链接文件很大，可以直接运行了。并且多个程序执行就会产生多个副本在内存中。

所以有了ELF第三种格式：共享对象文件（动态链接库）

### Linux内核调度

Linux中，进程可以分为两种，实时进程和普通进程，实时进程就是优先级比较高，可以马上拿到结果的;普通进程就是我们绝大多数的进程。不同的进程类型有不同的调度策略。
在 task_struct 中，有一个成员变量，我们叫调度策略。配合调度策略的，还有刚才说的优先级，也在 task_struct 中。优先级其实就是一个数值，对于实时进程，优先级的范围是 0～99；对于普通进程，优先级的范围是 100～139。数值越小，优先级越高
实时调度策略

1. 先来先到，高优先级可以抢占低优先级
2. 时间片轮流调度算法
3. 最短剩余时间优先。
普通调度策略
完全公平调度算法CFS

CFS 会为每一个进程安排一个虚拟运行时间 vruntime。如果一个进程在运行，随着时间的增长，也就是一个个 tick 的到来，进程的 vruntime 将不断增大。没有得到执行的进程 vruntime 不变。显然，那些 vruntime 少的，原来受到了不公平的对待，需要给它补上，所以会优先运行这样的进程。

CFS对于高优先级的进程的虚拟运行时间容量分配不同的，比如一个容量100毫升的杯子装了50毫升和一个50毫升的杯子装了25毫升，这两个进程是公平的。

### CFS的调度队列

CFS需要一个数据结构获取最短的vruntime，所以这边采用的事红黑树这个结构
每个cpu包含一个实时进程队列和CFS运行队列，在调度时，调度器首先会先去实时进程队列找是否有实时进程需要运行，如果没有才会去 CFS 运行队列找是否有进程需要运行，也就是每次都取CFS的最左边的节点。

## 内存管理

### 规划虚拟地址空间

操作系统的内存管理，主要分为三个方面。第一，物理内存的管理，相当于会议室管理员管理会议室。第二，虚拟地址的管理，也即在项目组的视角，会议室的虚拟地址应该如何组织。第三，虚拟地址和物理地址如何映射，也即会议室管理员如何管理映射表。

虚拟内存被分为内核态和用户态，并不是内核态的内存就直接使用物理内存，内核态也是大部分使用虚拟内存的，直接操作物理内存的永远只有内存管理模块。

### 内存的模块

内核为每个task_struct分配虚拟内存空间的时候，是有一定格式的，从低位开始，分为：

1. Text Segment

   代码段，也就是我们程序最后可执行文件ELF格式中的代码段

2. Data Segment

   存放静态变量

3. BSS Segment

   存放未初始化的静态变量

4. 堆段

   堆段是往高地址增长的区域

5. Memory Mapping Segment

   可以将文件映射到内存，比如需要一些so动态链接库。

6. 栈段

   存放主线程的一些栈参数

以上是用户空间进程看见的内存空间，互相隔离，不可见，但是如果到了内核态，每个进程看见的都是同一块内核空间。

内核空间内存的分配同样有代码段、静态变量数据段、未初始化静态变量等

我们使用fock创建进程后，需要调用exec去执行一个二进制文件，exec除了将elf格式的二进制文件加载到内存中，还需要将一些链接文件加载进来，比如动态链接库，那么我们还需要调用load_elf_binary系统调用去加载这些文件到指定的内存空间，这个函数主要做了以下这些事：



### 分段机制

分段机制下的虚拟地址由两部分组成，**段选择子和段内偏移量**。段选择子就保存在咱们前面讲过的段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。虚拟地址中的段内偏移量应该位于 0 和段界限之间。如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

在 Linux 里面，段表全称段描述符表（segment descriptors），放在全局描述符表 GDT（Global Descriptor Table）里面

### 分页机制

对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以暂时写到硬盘上，称为换出。一旦需要的时候，再加载进来，叫做换入。这样可以扩大可用物理内存的大小，提高物理内存的利用率。

虚拟地址分为两部分，**页号和页内偏移**。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。

### 多级页表

这样就实现了页表目录的实现。







