## B+树和B树的区别

https://zhuanlan.zhihu.com/p/27700617

https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&mid=2247484041&idx=1&sn=76d3bf1772f9e3c796ad3d8a089220fa&chksm=f9b784b8cec00dae3d52318f6cb2bdee39ad975bf79469b72a499ceca1c5d57db5cbbef914ea&token=2025456560&lang=zh_CN&scene=21#wechat_redirect

- B+树所有叶子节点都用指针链接起来，而B树仅仅是一个M叉搜索树
- B+树所有非叶子节点只储存数据索引，不包含数据。而B树每个节点都是包含数据和指针
- B+树叶子节点从左到右依次增大，而B树在数据大小上只遵循搜索树。

## B+树特点

- B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；

- B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
  
   - B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
- B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。
   - 查询的时间复杂度是O(logm(n))这个m是底数

   **B树**相对于**B+树**的优点是，如果经常访问的数据离根节点很近，而**B树**的**非叶子**节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比**B+树**快。

## hashmap地址冲突如何解决

### 开放寻址

如果哈希值对应的位置已经被占用，那么就从当前位置开始往后线性探测，直到找到。如果遇到一个空闲节点，则表示这个数据不在哈希表中，就插入。查找的过程也一样。开放寻址解决冲突除了线性探索还有：

### 二次探测

改变线性探测中的步长，变为二次方。hash(key)+0，hash(key)+12，hash(key)+22……

### 双重散列

不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。

开放寻址当装载因子过大的时候需要扩容，扩容的时候就需要做一些相对来更多的工作。

### 链表法

### 重哈希法，也就是发生冲突的时候重新使用另一个哈希函数进行哈希

## hashmap 是否线程安全

不是。因为存在以下情况：

- **插入的时候**，两个线程同时对一个key进行更新，那么A先赋值以后，B会覆盖掉A做的修改
- **扩容的时候**，多个线程同时扩容，需要对所有键值重新计算映射到新的哈希表，那么最后只会有一个线程的扩容成功
- **删除数据时候**。当一个线程进行查找时候，线性探测到空闲位置则表示不存在这个值，但是如果这个值是另一个线程同时删除的，那么会让另一个线程原本存在的数据变为不存在

## 为什么TOPk问题用堆排序好？

因为堆排序相对于其他的线性排序最大的优点就是它是树型的数据结构，所以如果是海量数据的时候，不需要将所有数据一次性加载到内存中进行排序，而只需一层一层下来读取就可以。

## 一致性哈希

https://zhuanlan.zhihu.com/p/24440059

## 排序算法总结

| Name     | 最差时间复杂度             | 最优时间复杂度             | 空间复杂度 | 是否是稳定排序                       |
| -------- | -------------------------- | -------------------------- | ---------- | ------------------------------------ |
| 冒泡排序 | O(n^2)                     | O(n)，已经有序，flag=false | O(1)       | 是的，只要if条件不变                 |
| 插入排序 | O(n^2)                     | O(n)，已经有序             | O(1)       | 是的                                 |
| 选择排序 | O(n^2)                     | O(n^2)                     | O(1)       | 不是                                 |
| 快速排序 | O(n^2)                     | O(nlogn)                   | O(1)       | 是                                   |
| 归并排序 | O(nlogn)                   | O(nlogn)                   | O(N)       | 是                                   |
| 堆排序   | 建堆（O(n)），排序O(nlogN) | 一样                       | O(1)       | 不是，两次排序后可能会改变相等值顺序 |

快速排序最差的情况：

如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)

## 哈希函数的设计

哈希函数的设计通常会遵循如下几个规则：

- 降低碰撞和溢出的产生
- 哈希函数不宜过于复杂，越容易计算越佳，但散列函数的映射关系越乱越好，消除映射之间的明显规律性
- 尽量把文字键值转换为数字键值，便于哈希函数运算
- 函数计算得到的值尽可能均匀分布在每一个桶中，不要太过于集中在某些桶内，这样可以降低碰撞，并减少溢出

对于数值型的key我们通常使用下面两种方法：

### 取模法

用余数做索引

### 基数转换法

对于字符型的key我们就无法直接进行取模，但是我们可以根据字符串编码将字符串转换成数值型后，通过基数转换。

基数转换就是确定一个基数（通常是素数），然后进行转码，然后转成二进制或者十进制变成我们需要的key

https://www.jianshu.com/p/88bd2a47ab1d

![](https://upload-images.jianshu.io/upload_images/17709149-f358b6d8d3e34d92.png?imageMogr2/auto-orient/strip|imageView2/2/w/796/format/webp)



