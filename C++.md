1. 各种类型大小

   https://blog.csdn.net/zy47675676/article/details/91474604?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase

   ![](https://img-blog.csdnimg.cn/20190611220525815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5NDc2NzU2NzY=,size_16,color_FFFFFF,t_70)

2. char (*p) [] 、char \*p[]、char (\*p)()的区别？

   由于[]的优先级高于\*，所以char(*p)[]是指向一个数组的指针，char \*p[]指的是一个存放指针的数组。

   char(\*p)()指的是返回值是char指针的一个方法

3. 手写int atoi(char *str)

   https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/

   ```c
   int strToInt(char* str){
       /*
       1.基本逻辑就是先判断空格，去除；然后判断©️，记录到flag
       2.往后找数字，换算成一个整数
       这里最重要的是整数溢出的判断，因为这边的数值范围是-2^31~2^31-1，也就是[-2147483648，2147483647]，所以我们在进行ans=ans*10+r之前，需要判断一下这一层的ans是否已经溢出整数的范围，
       两种情况：
       1.ans>INT_MAX/10，也就是ans>214748364，那么一定溢出了
       2.ans==INT_MAX/10 && r>7，也就是214748364这一部分是一样的，需要比较个位，所以只要大于7，
       就是溢出了。
   
       */
       int ans=0;
       int flag=1;
       int r;
       while(*str==' ') str++;
       if(*str=='-') flag = -1;
       if(*str=='+' || *str=='-') str++; 
       while(*str>='0' && *str<='9')
       {
           r=*str-'0';
           if(ans>INT_MAX/10 || ans==INT_MAX/10 && r>7) return flag==1?INT_MAX:INT_MIN;
           ans=ans*10+r;
           str++;
       }
       return ans*flag;
   }
   ```

4. 指针和引用的区别

   - 指针是一个变量，而引用只是别名，所以指针本身后开辟栈空间储存，而引用本身不占空间
   - 指针可以有多级指针，但是引用只能一级
   - 指针可以的是空指针，而引用不能指向空
   - 指针的值在初始化完后可以重新指向，而引用不能重新指向新对象

5. C和C++的区别

   https://www.zhihu.com/question/28834538/answer/100698972

   C++是面向对象的语言，而C是面向过程的。C++几乎是C的超集，C++比C多了很多的语法概念，就像RALL，rall是资源初始化的概念，资源的使用至少有三个阶段，也就是资源的获取，使用，释放。但是这个释放经常被忘记，C++不像java，python可以自己释放资源，而是需要程序员手动释放。所以RALL就是C++将资源获取的过程封装成一个类，通过构造函数获取资源，析构函数释放资源，这也是正好利用了C++的特性。

   https://zhuanlan.zhihu.com/p/34660259（RALL原理介绍）

6. const

   - c++中的const默认是内部连接，c中默认是外部链接，内部连接是不能只声明不赋值的。
   - c++中const对于基础类型不会开辟内存，而是放在符号表中，而如果以变量的形式定义const修饰的变量则会开辟内存。

7. const 和 constexpr区别

   - Constexpr  是编译期常量也就是编译器在编译的时候就可以计算这个值；const是运行时常量，也就是在编译期间是不知道const储存的值的

     ```c++
     const int num1=3;
     const int []={num1} //错误，编译到这里不知道num1的值
     ```

   - ```c++
     const int *p=a;  //指向一个整型常量的指针
     constexpr int *p=a;   //指向一个整型的常量指针
     ```

   - constexpr修饰的函数，返回值不一定是编译期常量

8. auto

   ```c++
   const int a=9;
   auto num=a;   //num是一个整型，会忽略顶层const
   auto &num=a;  //num是一个整型常量
   ```

9. NULL和nullptr

   NULL在C++中是整数0，为什么NULL不能是空指针，因为C++中不能将void类型的指针隐形转换，所以NULL不可定义为void*

10. 函数重载

   相同名字不同参数，但是不能是仅仅返回值不同，因为这样会产生二义性。

   相同名字不同参数的函数在编译器编译的时候会产生两个不同的名字，来表示两个不同的方法。

   **类型安全连接**

   道函数实际上应该是f（int），但编译器并不知道，因为它被告知—通过一个 

   明确的声明—这个函数是f（char）。因此编译成功了，在C中，连接也能成功，但在C++中却不行。因为编译器会修饰这些名字，把它变成了诸如f_int之类的名字，而使用的 

   函数则是f_char。当连接器试图找到f_char引用时，它只能找到f_int，所以它就会报告一条 

   出错信息。这就是类型安全连接。

11. static

    静态成员可以脱离类的作用域，独立于该类的任意对象

    - 静态成员函数可以直接访问static成员但是不能直接访问非static
    - static成员函数没有this指针，因为static是独立于类的对象的，this指向的正是对象
    - static成员不能在定义的时候初始化，但是只要是 static const int a=30，这样有const修饰就可以（const是内部连接，必须初始化就定义）
    - 非static的数据成员不能作为另一个成员函数的实参，因为它的值不能独立于所属的对象，而static变量可以。也就是对象是不能通过访问符去访问到实参的，而static修饰的可以当作是一个全局变量，所以是可以的。
    - 静态成员函数中没有this指针，不能访问一般的数据成员只能访问静态成员
    - 一个类中的所有静态成员变量都在一个静态储存区内，所以对于一个类的所有对象而言，这个静态变量相当于一个全局变量

12. 引用

    - 不能有NULL引用

    - 指针引用

      ```cpp
      void increment(int*& i){i++}
      ```

      这里是i地址增加了而不是i指向的内容增加了

    - 

13. union

    https://zhuanlan.zhihu.com/p/131458347

    联合体，体内的变量共享内存大小，大小为体内最大的值大小。

14. const和define

    1. const是运行时常量，二而define 是编译期的宏定义
    2. define没有类型，所以没有类型检查，而const有类型检查在编译期间
    3. define时宏展开，哪里使用哪里展开，不占内存；而const会分配内存。

15. C++和C的const区别

    c++中默认const是内部连接，也就是只对本文件有用，extern声明后才会变成外部链接；C中默认是外部链接。

    所以c++默认链接不会创建内存给全局的字面值常量，而局部的非static const值会储存在内存空间的栈空间中

16. 内联函数

    https://zhuanlan.zhihu.com/p/101090186

    - C++编译器编译的最终产物是程序，程序就是一连串的指令集合，运行时系统将这些指令放到内存中，所以这些指令都有对应内存地址。程序执行时，CPU的控制器会将这些指令不断的将代码段的指令拿到控制器的指令指针寄存器，然后结合运算单元和数据单元来执行指令，当执行到函数调用指令后，会先保存该指令的地址，并把函数参数复制到函数的堆栈中，函数执行完后再跳转到原地址。
    - 内联函数将自己的代码和其他程序联合起来，像是被嵌套进其他程序，这样程序就不需要跳转，而是顺序执行了，因此内联函数的运行速度会更快，但是代价就是消耗更多的内存
    - 所有的类内部的函数是默认内联函数（除了虚函数，并且是在类内部定义实现的，在类外实现就不是内联了），但是是否采用内联函数是编译器决定的，而不是一定会用。
    - 虚函数当非多态调用的时候也是可以使用内联的：https://www.zhihu.com/question/45894112/answer/100282374
    - 

17. C++程序的处理过程

    1. 预处理阶段

       g++ -E demo.cpp -o demo.i

       主要处理的是#include和#define，把引入的头文件放到引入位置，把define的宏用实际的字符串。

    2. 编译阶段

       g++11 -s demo.i -o demo.s

       检查代码的规范性、语法错误，然后翻译成汇编语言

    3. 汇编阶段

       g++11 -c demo.s -o demo.o

       把.s文件转换成.o文件

       这是一个二进制文件，里面包含了一些全局变量、二进制可执行代码、符号表（记录了函数和变量）、只读数据等。

    4. 链接阶段

       因为代码里面有些函数是没有被实现的，像printf、cout这样的函数，虽然在引入的头文件上有这些函数声明，但是没有被实现。所以需要将这些函数从函数库链接进来，一般从默认从/usr/lib下找

       主要分为 **静态链接库和动态链接库**

       - 动态链接库

         在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销，一般是.so文件，window下是.dll

       - 静态链接库

         在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中**，linux下是.a文件，windows下是.lib文件

18. 动态链接库和静态链接库制作

    - 概念

      上面有

    - 制作

      1. 动态链接库

         Max.cpp

         ```cpp
         int max(int a, int b, int c)
         {
            int max = ( a < b ) ? b : a;
            return ( ( max < c ) ? c : max );
         }
         ```

         ```shell
         g++11 -fPIC -shared -o libmax.so demo.cpp
         ```

         生成了.so文件，`PIC` 是 Position Independent Code 的缩写，表示要生成位置无关的代码，这是动态库需要的特性；`-shared` 是链接选项，告诉gcc生成动态库而不是可执行文件

         Max.h

         ```cpp
         #ifndef __MAX_H__
         #define __MAX_H__
         
         int max(int a, int b, int c);
         
         #endif
         ```

         Test.cpp

         ```cpp
         #include <stdio.h>
         #include "max.h"
         
         int main(int argc, char *argv[])
         {
             int a = 12, b = -2, c = 120;
             printf("The max value of 12, -2 and 120 is %d.\n", max(a, b, c));
             return 0;
         }
         ```

         ```c++
         g++11 max.cpp -L. -lmax -o max
         ```

         测试

      2. 静态链接库

         ar命令

19. static

    - static变量处于程序的静态储存区，而不是存在于栈区间

      ```c++
      #include<iostream>
      using namespace std;
      char get_num(const char* chararr=0){
          static const char *s;
          if(chararr){
              s=chararr;
          }
          return *s++;
      }
      int main()
      {
          char *str="scw3837";
          get_num(str);
          for(int i=0;i<3;i++){
              cout<<get_num()<<endl;  //输出c、w、3
          }
          return 0;
      }
      ```

      比如get_num函数如果不传递参数chararr，那么就会使用静态区变量

20. 内部连接和外部链接

    https://zhuanlan.zhihu.com/p/150001991

    每个cpp文件都是以一个单独的编译单元，每个编译单元就是独立的单元，相互不可见。

    - 内部连接（static）

      如果一个名称对编译单元来说是局部的，在链接的时候其他编译单元无法链接到它且不会与其他编译单元中的同样名称相冲突。（例如被关键字static，inline标识）

    - 外部链接（extern）

      如果一个名称对编译单元来说不是局部的，而在链接的时候其他的编译单元可以访问它，也就是说它可以和别的编译单元交互。

21. extern和static

22. 宏定义#define

    宏替换，被define替换的值在最后编译出来的代码中是不存在的，因为在预处理阶段就会被替换掉。比如#define success 1，最后编译的代码中不会有success，而是都被替换成1。

    define和const的区别在于：

    1. 上面说明的这点，而const定义的值存在于最后的编译代码
    2. define无法指定变量的类型

23. 封装、继承、多态

    是面向对象的三大特性

    1. 封装

       面向对象的基本特征之一，就是将一系列功能相关的方法统一放到一个类中，类可以控制函数或者变量的权限。

    2. 继承

       是一个类对于功能复用的措施，子类可以继承父类的一些功能函数，一个类继承而来的成员的访问权限受两个因素的影响，一个是基类中成员的访问权限，另一个是以何种权限去继承基类。第二种继承方式其实是为了限制派生类的实例访问权限，比如类B是基类A的派生类，并且以private方式继承，所以B的实例是无法访问基类A中的成员，即使这个基类成员在基类中是public的。

       继承中有一些注意点：

       - 基类中的析构函数一般设计成虚函数，但不一定是纯虚的
       - 在class后加上final可以防止类被继承

    3. 多态

       涉及到虚函数、纯虚函数、虚表

24. 虚函数

    继承过程中，主要有两种成员函数，一种是希望基类可以直接继承不需改变的函数，另一种的希望派生类重写并覆盖的函数。对于第二种，就是定义为**虚函数**。任何除了构造函数的非静态函数都可以被定义成抽象函数。

    **虚函数的调用是在运行阶段动态绑定的，而不是在编译阶段静态绑定的**

    ![v2-1854c774aa4a93c8e85e7458f74ecc02_1440w.jpg](https://i.loli.net/2020/07/26/3kx8ej5TmLYrRGX.jpg)

    - 基类中的虚函数被子类继承后子类中这个方法也同样是虚函数。

    - 继承而来的虚函数返回类型，参数都要一样

    - 只有虚函数，在子类中才能override:

      ```cpp
      class A{
        virtual void get_num(int num);
      }
      class B:public A{
        void get_num(int num) override;
      }
      ```

    - 在成员函数后加上final，在子类中就不能被重写

25. 纯虚函数

    为了方便使用多态的特性，我们需要在基类中定义一些虚函数，并且有虚函数的基类有时候不需要进行实例化，比如动物类可以有猫狗这样的派生类，但是动物本身的实例是没有意义的，所以这样的类可以被定义成抽象类，**而抽象类的定义就是至少含有一个纯虚函数的类**，纯虚函数声明如下： virtual void funtion1()=0

26. 动态绑定和静态绑定

    这个可以看23虚函数那边，虚函数实现机制就是动态绑定的。

    如果类不包含虚函数，那么编译器在编译期间就会把成员函数的地址确定下来，后面调用的时候只是去对应的地址（在符号表中）去拿就行了，**这就是静态绑定**

    ``` cpp
    class A{
      virtual void show();
    }
    class B:public A{
      virtual void show();
    }
    int main(){
      B b;
      A* a=&b;
      a->show();//这边调用的是B的show函数，虽然a是A指针类型
    }
    ```

    上面这个现象：基类指针指向了派生类的对象，调用的虚函数会是派生类的虚函数叫做 **动态绑定**，如果不是虚函数，那么无论a怎么指向，都是调用基类的函数。**动态绑定的原理就是虚表的实现**

27. 虚表

    在有虚函数的类编译期间，会在该类编译成二进制文件并加载到内存中的时候在堆区加一个虚表指针指向全局数据区中的虚表，所以如果在程序中使用sizeof打印有虚函数的类大小，发现会比不含虚函数的类大几个字节（根据计算机决定，32位是32/8=4字节，64位是8字节），虚表中会有多个多个虚表指针指向不同虚函数的内存地址。**每个类的实例都会有自己的虚表指针**，所以动态绑定的时候就是根据类指针去对应的虚表中寻找虚函数地址。

28. 构造函数和析构函数可以是虚函数吗？

    构造函数不能是虚函数，因为虚函数是为了多态的实现，并且是动态绑定的，动态绑定的前提是有对象，但是有对象的前提是有构造函数实现，所以互相矛盾。

29. 构造函数和析构函数中能否调用虚函数？

    能，但是不建议。为什么？因为如果构造函数中调用虚函数，那么继承的时候是先调用基类构造函数然后调用子类的，所以如果在构造函数中调用虚函数，那么基类调用的虚函数就是基类的虚函数，到了子类也是调用基类的虚函数，这就破坏了多态的原则。

    而析构函数，是先调用子类的析构函数，此时是调用的子类自己的虚函数，到了基类后，调用的是基类的虚函数，不是子类的。

    **所以总结来说，如果构造函数和析构函数中调用虚函数，就不会触发多态，这不是语法上的问题，而是标准的问题**

30. C++的内存管理机制

    https://zhuanlan.zhihu.com/p/51855842

    c++程序的内存布局由低地址往高地址分别是

31. 类的拷贝、移动、赋值、销毁

32. 析构函数不能为删除的函数

    删除的函数定义是这样：

    ```c++
    void func()=delete;
    ```

    如果是把拷贝构造函数设为delete，那么表示无法使用该类的拷贝构造。

    但是析构函数如果被删除，那么就无法删除这个类的对象了。

    ```cpp
    class S{
       ~S()=delete;
    }
    S s1;  //错误
    S *s1 = new S();   //正确但是无法使用析构函数
    ```

    
