1. B+树和B树的区别

   https://zhuanlan.zhihu.com/p/27700617

   https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&mid=2247484041&idx=1&sn=76d3bf1772f9e3c796ad3d8a089220fa&chksm=f9b784b8cec00dae3d52318f6cb2bdee39ad975bf79469b72a499ceca1c5d57db5cbbef914ea&token=2025456560&lang=zh_CN&scene=21#wechat_redirect

   - B+树所有叶子节点都用指针链接起来，而B树仅仅是一个M叉搜索树
   - B+树所有非叶子节点只储存数据索引，不包含数据。而B树每个节点都是包含数据和指针
   - B+树叶子节点从左到右依次增大，而B树在数据大小上只遵循搜索树。

2. B+树特点

   - B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；
- B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
   
   - B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
- B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。
   - 查询的时间复杂度是O(logm(n))这个m是底数

   **B树**相对于**B+树**的优点是，如果经常访问的数据离根节点很近，而**B树**的**非叶子**节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比**B+树**快。

3. hashmap地址冲突如何解决

   - 开放寻址    如果哈希值对应的位置已经被占用，那么就从当前位置开始往后线性探测，直到找到。如果遇到一个空闲节点，则表示这个数据不在哈希表中，就插入。查找的过程也一样。开放寻址解决冲突除了线性探索还有：
     1. 二次探测。改变线性探测中的步长，变为二次方。hash(key)+0，hash(key)+12，hash(key)+22……
     2. 双重散列。不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。
   - 链表法

4. hashmap 是否线程安全

   不是。因为存在以下情况：

   - **插入的时候**，两个线程同时对一个key进行更新，那么A先赋值以后，B会覆盖掉A做的修改
   - **扩容的时候**，多个线程同时扩容，需要对所有键值重新计算映射到新的哈希表，那么最后只会有一个线程的扩容成功
   - **删除数据时候**。当一个线程进行查找时候，线性探测到空闲位置则表示不存在这个值，但是如果这个值是另一个线程同时删除的，那么会让另一个线程原本存在的数据变为不存在

5. 为什么TOPk问题用堆排序好？

   因为堆排序相对于其他的线性排序最大的优点就是它是树型的数据结构，所以如果是海量数据的时候，不需要将所有数据一次性加载到内存中进行排序，而只需一层一层下来读取就可以。