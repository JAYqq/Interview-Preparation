1. 为什么需要操作系统

   如果没有操作系统，那么编写程序就需要去自己开辟内存，并且还要知道内存怎么去定位等等，必须去对不同的硬件调用不同的功能函数，操作系统本质上也是一个程序，这个程序将所有硬件功能函数做了封装，为软件开发提供了接口。系统内核程序开机后一直在内存中，并且这块区域是受保护的

2. 内核和操作系统

   内核是操作系统的核心，内核主要是和硬件打交道，封装了很多与硬件之间交互的接口提供给开发者，而操作系统的范围更大，因为它不仅包括内核，还要做很多像提供界面给用户，

3. 进程和线程的区别

   https://zhuanlan.zhihu.com/p/105086274

   **进程对于操作系统来说就是一个数据结构，拿Linux来讲**

   ```c
   struct task_struct {
       // 进程状态
       long              state;
       // 虚拟内存结构体
       struct mm_struct  *mm;
       // 进程号
       pid_t             pid;
       // 指向父进程的指针
       struct task_struct   *parent;
       // 子进程列表
       struct list_head      children;
       // 存放文件系统信息的指针
       struct fs_struct      *fs;
       // 一个数组，包含该进程打开的文件指针
       struct files_struct   *files;
   };
   ```

   这里面比较重要的是进程号、指向虚拟内存的指针、进程打开的文件指针（结合Linux的文件系统来说），还有上下文数据也就是保存了上一次运行时的数据。

   **操作系统将所有PCB通过双向链表连接起来**

   Linux下进程的创建是fock()，线程的创建是pthread()，但是两个都是使用了上面这一种数据结构

   进程是操作系统资源分配的基本单位，这些资源主要包括CPU、内存、文件、端口等，进程最大责任就是对这些操作系统分配的资源进行管理，像内存管理，系统中多个进程同时运行，系统就需要对这些进程通过虚拟逻辑地址映射到物理内存上，将不同块内存分别划分给这些进程。正是因为进程拥有更多的资源，所以进程切换的成本会比线程更大。

   线程的话是生存在进程之中，多个线程之间是共享一个进程的资源的，共享资源就意味着冲突的，如果是互斥资源的话，进程就可以对此资源加上互斥锁，如果是允许多个线程共享的资源，那么就涉及到信号量机制，这也是进程对线程的管理

   所以我觉得进程和线程是在操作系统中不同层面的概念，线程在进程中主要关注处理器执行代码的过程，而进程关注的是内部资源的管理和保护。

4. 进程和程序的区别

   - 储存位置不同，程序储存在硬盘上，进程在内存中
   - 程序是静态的，而进程是动态的，它会在就绪、阻塞、执行之间转换
   - 

5. 为什么Linux下线程进程创建的更快？

   **copy-on-write** 的策略优化。由于进程中创建的多个线程之间是共享进程资源的，像内存、文件等，对于内存，线程创建的时候不会直线先拷贝内存空间，而是等到线程有写操作的时候才会去复制，所以更快了。

6. 为什么多进程下载更快

   这个直接的原因是窗口大小的问题，而根本原因是TCP的拥塞控制算法的不精准。TCP约束性能主要有流控和拥塞控制，流控主要是参考接受方，跟链路无关，所以主要的原因出在拥塞控制。

   单个线程开启单个TCP链接，在传输数据的时候如果出现丢包，那么就会导致拥塞控制算法会调整窗口大小，然后缓慢增加窗口大小，而这个缓慢增加的过程可以用多线程来避免，因为多个线程可以更快速调整窗口大小，使平均窗口大小会更大。而单线程要占满带宽需要意味着窗口大小要足够大，但是单线程无法保证一直满带宽。

7. 进程调度

   ###  批处理系统

   批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

   也就是用户提交了作业以后，就和操作系统不打交道了。

   **1.1 先来先服务 first-come first-serverd（FCFS）**

   非抢占式的调度算法，按照请求的顺序进行调度。

   有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

   **1.2 短作业优先 shortest job first（SJF）**

   非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

   长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

   **1.3 最短剩余时间优先 shortest remaining time next（SRTN）**

   最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

   ## 交互式系统

   交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

   **2.1 时间片轮转**

   将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

   时间片轮转算法的效率和时间片的大小有很大关系：

   - 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
   - 而如果时间片过长，那么实时性就不能得到保证。

   [![img](https://camo.githubusercontent.com/8ff909218be7e1269ee5912f0aba9fcb3552df3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)](https://camo.githubusercontent.com/8ff909218be7e1269ee5912f0aba9fcb3552df3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)

   

   **2.2 优先级调度**

   为每个进程分配一个优先级，按优先级进行调度。

   为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

   **2.3 多级反馈队列**

   一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

   多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

   每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

   可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

8. 进程之间的通信

   https://zhuanlan.zhihu.com/p/123377340

9. 中断调用过程

   - 系统将所有中断信号进行编号，这个编号叫做中断向量。中断向量和中断服务程序的对应关系是由中断向量表决定的，系统设置了中断向量和中断描述符的对应关系，中断服务程序由操作系统决定。
   - CPU在执行完每一条指令之后，去确认中断控制器是否有中断请求过来，如果有，CPU就会读取中断请求对应的中断向量，对于异常或者系统调用这样的软中断，中断向量是直接给出的。
   - CPU对照中断向量表拿到对应的中断描述符，中断描述符里面保存了段选择符
   - 然后根据段选择符从GDT（全局描述符）中获取段描述符，，里面保存了中断服务程序的基地址和属性信息。还要检查中断描述符的DPL（特权级），确保中断服务程序的特权级是高于当前程序的（特权级分为0~3,0最高表示内核级别，3最低表示用户态，低级别能够访问高级别），像一些异常系统调用。
   - CPU进行特权级的判断，如果特权级发生变化，就需要切换到中断服务程序运行需要的栈。
   - CPU开始栈保护停止执行的程序的上下文。
   - CPU开始执行中断服务程序的第一条指令
   - 中断服务程序处理完后，将之前程序的上下文出栈恢复程序。

### IO模型

IO操作都涉及到两步：系统调用和内核态将数据拷贝到用户态

https://zhuanlan.zhihu.com/p/126286726

**阻塞IO**

调用recev()方法，socket中没有数据就会阻塞在这里，直到有了数据才会接受并返回

**非阻塞IO**

让recev()没有数据就先回到用户态去执行其他操作，等一会再去socket拿数据

**IO复用**

也就是select、poll、epoll，他们三种系统调用本质上也是阻塞IO，他们在recev之前阻塞，socket收到数据后会主动唤醒进程。主要的改进在于他们可以一个进程同时监听多个socket

**信号驱动IO模型**

接受到数据后触发中断服务程序告知程序来收数据，还是同步IO

**异步IO**

内核等数据准备好之后主动将数据拷贝到用户态并通知程序，这时候程序只需要直接去操作数据就可以。

**所以异步IO和同步IO主要区别在第二步也就是拷贝数据，同步IO的阻塞都是发生在这里。**

