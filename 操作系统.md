[TOC]



## 为什么需要操作系统

如果没有操作系统，那么编写程序就需要去自己开辟内存，并且还要知道内存怎么去定位等等，必须去对不同的硬件调用不同的功能函数，操作系统本质上也是一个程序，这个程序将所有硬件功能函数做了封装，为软件开发提供了接口。系统内核程序开机后一直在内存中，并且这块区域是受保护的

## 内核和操作系统

内核是操作系统的核心，内核主要是和硬件打交道，封装了很多与硬件之间交互的接口提供给开发者，而操作系统的范围更大，因为它不仅包括内核，还要做很多像提供界面给用户。

## 句柄

句柄通常是一个整数，通过这个数字去标记一些资源，比如在Linux中文件描述符就是一个句柄类型。

## 进程管理

### 进程和线程的区别

https://zhuanlan.zhihu.com/p/105086274

**进程对于操作系统来说就是一个数据结构，拿Linux来讲**

```c
struct task_struct {
    // 进程状态
    long              state;
    // 虚拟内存结构体
    struct mm_struct  *mm;
    // 进程号
    pid_t             pid;
    // 指向父进程的指针
    struct task_struct   *parent;
    // 子进程列表
    struct list_head      children;
    // 存放文件系统信息的指针
    struct fs_struct      *fs;
    // 一个数组，包含该进程打开的文件指针
    struct files_struct   *files;
    ....(还有很多结构)
};
```

这里面比较重要的是进程号、指向虚拟内存的指针、进程打开的文件指针（结合Linux的文件系统来说），还有上下文数据也就是保存了上一次运行时的数据。

**操作系统将所有PCB通过双向链表连接起来**（因为进程会经常面临创建和删除的操作）

Linux下进程的创建是fock()，线程的创建是pthread()，但是两个都是使用了上面这一种数据结构

进程是操作系统资源分配的基本单位，这些资源主要包括CPU、内存、文件、端口等，进程最大责任就是对这些操作系统分配的资源进行管理，像内存管理，系统中多个进程同时运行，系统就需要对这些进程通过虚拟逻辑地址映射到物理内存上，将不同块内存分别划分给这些进程。正是因为进程拥有更多的资源，所以进程切换的成本会比线程更大。

线程的话是生存在进程之中，多个线程之间是共享一个进程的资源的，共享资源就意味着冲突的，如果是互斥资源的话，进程就可以对此资源加上互斥锁，如果是允许多个线程共享的资源，那么就涉及到信号量机制，这也是进程对线程的管理

所以我觉得进程和线程是在操作系统中不同层面的概念，线程在进程中主要关注处理器执行代码的过程，而进程关注的是内部资源的管理和保护。

### 进程和程序的区别

- 储存位置不同，程序储存在硬盘上，进程在内存中
- 程序是静态的，而进程是动态的，它会在就绪、阻塞、执行之间转换

### 进程的状态

三种基本状态：

- 运行状态
- 就绪    已经获取了全部资源，等待CPU调度
- 阻塞    还没有获取到所有资源，等待资源的分配

其他状态

- 创建状态   正在被创建
- 结束状态   正在回收资源的状态
- **挂起**          进程挂起的时候就是把进程从内存放到主存

**状态队列**

系统为每个状态下的进程维护了一个队列，当一个进程的状态发生了改变，就会转移对应的PCB

### 为什么Linux下线程进程创建的更快？

**copy-on-write** 的策略优化。由于进程中创建的多个线程之间是共享进程资源的，像内存、文件等，对于内存，线程创建的时候不会直接先拷贝内存空间，而是等到线程有写操作的时候才会去复制，所以更快了。

### 为什么多进程下载更快

这个直接的原因是窗口大小的问题，而根本原因是TCP的拥塞控制算法的不精准。TCP约束性能主要有流控和拥塞控制，流控主要是参考接受方，跟链路无关，所以主要的原因出在拥塞控制。

单个线程开启单个TCP链接，在传输数据的时候如果出现丢包，那么就会导致拥塞控制算法会调整窗口大小，然后缓慢增加窗口大小，而这个缓慢增加的过程可以用多线程来避免，因为多个线程可以更快速调整窗口大小，使平均窗口大小会更大。而单线程要占满带宽需要意味着窗口大小要足够大，但是单线程无法保证一直满带宽。

### 进程调度

####  批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

也就是用户提交了作业以后，就和操作系统不打交道了。

##### 先来先服务 first-come first-serverd（FCFS）

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

##### 短作业优先 shortest job first（SJF）

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

##### 最短剩余时间优先 shortest remaining time next（SRTN）

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

#### 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

##### 时间片轮转

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

[![img](https://camo.githubusercontent.com/8ff909218be7e1269ee5912f0aba9fcb3552df3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)](https://camo.githubusercontent.com/8ff909218be7e1269ee5912f0aba9fcb3552df3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)



##### 优先级调度

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

##### 多级反馈队列

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

### 进程之间的通信

由于进程的地址空间是相互独立的，所以通信往往需要借助第三方来实现。

https://zhuanlan.zhihu.com/p/123377340

- 匿名管道通信

  1.父进程调用pipe开辟管道,得到两个文件描述符指向管道的两端。

  2.父进程调用fork创建子进程,子进程会拷贝一份父进程的struct files_struct，那么子进程也有两个文件描述符指向同一管道。

  3.父进程关闭管道读端,子进程关闭管道写端。父进程可以往管道里写,子进程可以从管道里读,管道是用环形队列实现的,数据从写端流入从读端流出,这样就实现了进程间通信。

  **缺点**

  只能单向传输、只能父子进程通信。

  **管道出现的四种特殊情况：**

  1.写端关闭，读端不关闭；

  那么管道中剩余的数据都被读取后,再次read会返回0,就像读到文件末尾一样。

  2.写端不关闭，但是也不写数据，读端不关闭；

  此时管道中剩余的数据都被读取之后再次read会被阻塞，直到管道中有数据可读了才重新读取数据并返回；

  3.读端关闭，写端不关闭；

  此时该进程会收到信号SIGPIPE，通常会导致进程异常终止。

  4.读端不关闭，但是也不读取数据，写端不关闭；

  此时当写端被写满之后再次write会阻塞，直到管道中有空位置了才会写入数据并重新返回。

- 有名管道

  有名管道是一个设备文件，不存在于内核而是存在于用户空间。所以允许任何进程之间通信，只要它们能访问这个设备文件。

- 信号量

  用来管理临界资源，相当于一个计数器，只支持PV操作

  P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行等待操作；

  V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1；

- 共享内存

  **是几种通信方式中效率最高的**，不需要通过内核，只需要在共享内存空间进行数据交换。系统分配两个进程的虚拟内存空间映射到了相同的物理内存空间。

- 消息队列

  管道通信如果读端不打开，那么写端就会阻塞，所以消息队列解决了这个问题，就是写完数据可以直接可以返回。但是因为这个过程涉及到数据的两次拷贝，所以当数据量比较大的时候就会影响效率。

  另外读进程也可以根据需求进行有选择的读取消息

- socket通信

  可以实现不同主机之间的通信，像HTTP

### 孤儿进程和僵尸进程

#### 孤儿进程

孤儿进程就是说一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 `init` 进程(进程`ID`为`1`的进程)所收养，并由 `init` 进程对它们完成状态收集工作。因为孤儿进程会被 `init` 进程收养，所以孤儿进程不会对系统造成危害。

#### 僵尸进程

僵尸进程就是一个fock()子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 `wait()` 或 `waitpid()` 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 `wait()` 或 `waitpid()`，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。僵尸进程通过 `ps` 命令显示出来的状态为 `Z`。

#### 如何处理这两种进程

孤儿进程由于会被init进程处理，所以当进程结束后就会释放。但是孤儿进程的大量存在就会占用大量的进程号，系统的可用进程号是有限的，所以必须通过杀死僵尸进程的父进程，让僵尸进程变成孤儿进程，这样就可以由init进程去处理了。

## 中断调用过程

- 系统将所有中断信号进行编号，这个编号叫做中断向量。中断向量和中断服务程序的对应关系是由中断向量表决定的，系统设置了中断向量和中断描述符的对应关系，中断服务程序由操作系统决定。
- CPU在执行完每一条指令之后，去确认中断控制器是否有中断请求过来，如果有，CPU就会读取中断请求对应的中断向量，对于异常或者系统调用这样的软中断，中断向量是直接给出的。
- CPU对照中断向量表拿到对应的中断描述符，中断描述符里面保存了段选择符
- 然后根据段选择符从GDT（全局描述符）中获取段描述符，，里面保存了中断服务程序的基地址和属性信息。还要检查中断描述符的DPL（特权级），确保中断服务程序的特权级是高于当前程序的（特权级分为0~3,0最高表示内核级别，3最低表示用户态，低级别能够访问高级别），像一些异常系统调用。
- CPU进行特权级的判断，如果特权级发生变化，就需要切换到中断服务程序运行需要的栈。
- CPU开始栈保护停止执行的程序的上下文。
- CPU开始执行中断服务程序的第一条指令
- 中断服务程序处理完后，将之前程序的上下文出栈恢复程序。

## 线程管理

### 线程的优点

1. 进程中可以创建多个线程并发
2. 线程之间的切换只需要切换一些必要的信息像寄存器、内存
3. 线程之间可以直接通过共享内存实现资源共享

### 线程分类

https://juejin.im/post/5da27254e51d4578282ce26d

- 用户线程

  在用户空间创建线程，通过一个线程库中的函数进行线程的创建，但是这些线程对于内核来说是不可见的，也就是他们都藏在进程中，系统此时还是按照进程来管理。所以，一个进程中的线程只能占用一个核，一个进程中只能同时有一个线程在运行占用CPU，其他线程只能等这个线程释放了CPU才能执行。

  这样明显很减分，一个阻塞，全都要等。所以有一个jacket方案，把一个阻塞的系统调用转换成非阻塞，首先jacket会去确定一下系统调用是否会阻塞，如果会那么就先在应用层阻塞这个线程，把控制权交给其他线程，这样可以尽量让其他非阻塞线程先执行，虽然最后还是会阻塞

- 内核线程

  也就是每次创建线程就进行系统调用，在内核中维护一个线程表（当然还是有进程表存在），可以让内核看见线程

  **优点**

  1. 一个进程的线程可以运行在多个核上，效率更高，充分发挥多核CPU
  2. 不会阻塞，因为此时内核也会对线程进行调度，而不会阻塞在一个线程上。

  **缺点**

  1. 让内核进行线程调度，意味着每次切换都要用户态和内核态的切换。
  2. 线程表在内核中空间是有限的，所以数量级肯定不能和用户级线程相比

### 线程的通信（同步）

其实线程的通信主要是为了线程的同步，因为多个线程共享一个进程的资源，这样导致了大量的竞争出现，所以需要有一些线程同步的处理。

1. 临界区。对一些公共资源进行访问限制
2. 信号量机制。
3. 锁机制
   - `互斥锁`确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。
   - `读写锁`当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。
   - `条件变量`可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
   - `自旋锁`上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。
4. 共享内存

## IO模型

IO操作都涉及到两步：系统调用和内核态将数据拷贝到用户态

https://zhuanlan.zhihu.com/p/126286726

### 阻塞IO

调用recev()方法，socket中没有数据就会阻塞在这里，直到有了数据才会接受并返回

### 非阻塞IO

让recev()没有数据就先回到用户态去执行其他操作，等一会再去socket拿数据

### IO复用

也就是select、poll、epoll，他们三种系统调用本质上也是阻塞IO，他们在recev之前阻塞，socket收到数据后会主动唤醒进程。主要的改进在于他们可以一个进程同时监听多个socket

### 信号驱动IO模型

接受到数据后触发中断服务程序告知程序来收数据，还是同步IO

### 异步IO

内核等数据准备好之后主动将数据拷贝到用户态并通知程序，这时候程序只需要直接去操作数据就可以。

**所以异步IO和同步IO主要区别在第二步也就是拷贝数据，同步IO的阻塞都是发生在这里。**



## 内存管理

https://blog.csdn.net/wang379275614/article/details/13765599

### 页式管理

逻辑空间分页，物理空间分块

页地址分为页号和位移量，位移量表示页的大小

![](https://img-blog.csdn.net/20131031074850828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

根据页表去找到对应块号，根据块号找到对应内存块，然后在块内移动位移量找到指定内存初始地址



### 段式管理

逻辑地址=段号+段内地址

物理地址=基址+块内地址

根据段表去判别段号对应的基址

![](https://img-blog.csdn.net/20131031091123328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

内存空间中的每一段都是连续有完整逻辑意义的分区。

### 分段和分页的区别

分页时，页的大小是固定的根据页面大小将程序切开，而分段是根据程序来，将一段完整意义的程序切开（像一个函数）





### 系统启动过程

第一个启动程序是BIOS，BIOS程序是储存在ORM中，也就是只读内存，BIOS会分析计算机的储存设备，然后到硬盘中读取MBR，也就是在硬盘中第一个磁区的位置，里面有启动管理程序。然后启动管理程序读取核心文件，核心文件就开始操作系统的功能



 